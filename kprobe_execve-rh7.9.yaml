# Count number of times a file was exec()-ed
# method: kprobe:sys_execve
#
# Code developed and tested to work with:
#
# CentOS Linux release 7.9.2009 (Core)
# 3.10.0-1160.36.2.el7.x86_64
# bcc-0.10.0-1.el7.x86_64
#
programs:
  - name: execve
    metrics:
      counters:
        - name: kprobe_sys_execve
          help: Calls to execve()
          table: files
          labels:
            - name: file_execed
              size: 128
              decoders:
                - name: string
                - name: regexp
                  regexps:
                    - ^/software/.*$
    kprobes:
      # grep execve /proc/kallsyms
      #do_execve: count_execve
      sys_execve: count_execve
    code: |

      #include <linux/fs.h>

      #define LENGTH 128

      struct callargs {
          char file[LENGTH];
      };

      BPF_HASH(files, struct callargs);

      #define SLURM "/var/spool/slurm"

      // https://elixir.bootlin.com/linux/latest/C/ident/sys_execve
      int count_execve(struct pt_regs *ctx, const char *filename) {

          struct callargs f={};
          u64 i=0,k=0;
          u64 zero=0;
          u64 *v;

      // do not add exec calls for slurm scripts e.g. "/var/spool/slurm/job946046/slurm_script"
          #pragma unroll
          for(i=0; i<sizeof(SLURM); i++) {
                if(filename[i]!=SLURM[i]) {
                        //bpf_trace_printk("ebpf: DIFF !\n");
                        break;
                }
          }
          if(i==sizeof(SLURM)-1) {
                //bpf_trace_printk("ebpf: MATCH!\n");
                return 0;
          }
          //bpf_trace_printk("ebpf: i, sizeof(SLURM) == %d %d!\n", i, sizeof(SLURM));
          
          // copy argument and manually 0-pad the rest of char[] after the first \0
          // because: bpf_probe_read_user_str() does: 
          // " In case the string length is smaller than size, the target is not padded with further NULL bytes."
          // ...and random chars after first \0 trigger " was collected before with the same name and label values" issue
          // don't know of a better way to do this so... 

          bpf_probe_read(&f.file, sizeof(f.file), filename);
          // bpf_trace_printk("ebpf: something triggered!\n");
          // bpf_trace_printk("ebpf: file %s \n", filename);

          // rh 7.9 support missing
          // loops not allowed? in 3.10 how do you do this then?
          // ...unroll? works.
          #pragma unroll
          for(int j=0; j<LENGTH; j++) {
              if(k!=0 || f.file[j]==0) {
                  k=1;
                  f.file[j]=0;
              }
          }

          // can we avoid doing this lookup?
          // why now? because: 
          // "When using map.atomic_increment() to operate on a BPF map of type BPF_MAP_TYPE_HASH, map.atomic_increment() does not guarantee the atomicity of the operation when the specified key does not exist."
          v=files.lookup_or_init(&f, &zero);

          if(v==NULL) {
              // goes to: `cat /sys/kernel/debug/tracing/trace_pipe`
              bpf_trace_printk("ebpf: map full!\n");
              return 0;
          }
          else {
              files.increment(f);
          }

          // bpf_trace_printk("ebpf: file %s counter %lu \n", f.file, *v );
          return 0;
      }
